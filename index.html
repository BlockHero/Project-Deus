<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Mini GTA ‚Äî Hybrid City</title>
<style>
:root{
  --ui-bg: rgba(0,0,0,0.34);
  --accent: #ff6b6b;
  --accent2: #50aaff;
  --hud-font: system-ui,Segoe UI,Roboto,Arial;
}
*{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
html,body{height:100%; margin:0; background:#07101a; font-family:var(--hud-font); -webkit-user-select:none; user-select:none;}
#gameWrap{position:relative; width:100%; height:100vh; overflow:hidden; touch-action:none;}
canvas#game{display:block; width:100%; height:100%; background:linear-gradient(#87c0ff,#7bb7ff);}

/* HUD */
#hud{position:absolute; left:12px; top:12px; z-index:120; color:#fff; font-size:14px; pointer-events:none;}
.hud-row{margin-bottom:8px}
.bar{width:170px; height:14px; background:rgba(255,255,255,0.08); border-radius:6px; overflow:hidden; border:1px solid rgba(0,0,0,0.35);}
.bar-fill{height:100%; border-radius:6px;}
#healthFill{background:linear-gradient(90deg,#ff624d,#ff8a6b); width:100%;}
#armorFill{background:linear-gradient(90deg,#5fb8ff,#3b82ff); width:100%;}
.hud-mini{font-size:12px; opacity:0.95; margin-top:6px;}
#wantedStars{display:inline-block; margin-left:6px; color:#ffd700}

/* Minimap */
#minimap{position:absolute; right:12px; top:12px; width:120px; height:120px; background:rgba(0,0,0,0.45); border-radius:8px; z-index:120; overflow:hidden; border:2px solid rgba(255,255,255,0.06);}

/* Joystick */
#joystickArea{position:absolute; left:12px; bottom:12px; width:150px; height:150px; z-index:110; touch-action:none;}
.joystick-bg{position:absolute; inset:0; border-radius:50%; background:var(--ui-bg); display:flex; align-items:center; justify-content:center; pointer-events:none;}
#stick{position:absolute; width:66px; height:66px; left:42px; top:42px; border-radius:50%; background:rgba(255,255,255,0.96); box-shadow:0 8px 18px rgba(0,0,0,0.45); transition:transform 0.02s linear;}

/* Buttons */
#shootBtn{position:absolute; right:100px; bottom:118px; z-index:110; width:70px; height:70px; border-radius:50%; background:var(--ui-bg); color:#fff; font-size:22px; border:2px solid rgba(255,255,255,0.08); pointer-events:auto;}
#enterBtn{position:absolute; right:100px; bottom:28px; z-index:110; width:70px; height:70px; border-radius:50%; background:var(--ui-bg); color:#fff; font-size:22px; border:2px solid rgba(255,255,255,0.06); pointer-events:auto;}
#pauseBtn{position:absolute; left:50%; transform:translateX(-50%); top:12px; z-index:120; background:var(--ui-bg); color:#fff; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); pointer-events:auto}

#sprintBtn{
    position:absolute;
    right:15px;
    bottom:10px; 
    z-index:110;
    width:70px;
    height:70px;
    border-radius:50%;
    background:var(--ui-bg);
    color:#fff;
    font-size:22px;
    border:2px solid rgba(255,255,255,0.06);
    pointer-events:auto;
}

/* Car controls - LEFT (turn) */
#carControlsLeft{position:absolute; left:12px; bottom:250px; z-index:115; display:none; flex-direction:column; gap:8px; pointer-events:auto;}
.car-btn{width:70px; height:70px; margin:6px; font-size:28px; color:#fff; background:var(--ui-bg); border-radius:12px; border:2px solid rgba(255,255,255,0.06);}

#carLeft {
  position: relative;  /* allow moving individually */
  left: -10px;         /* move left/right */
  top: 170px;            /* move up/down */
}

#carRight {
  position: relative;
  left: 70px;
  top: 80px;
}

/* Car controls - RIGHT (throttle/brake/exit) */
#carControlsRight{position:absolute; right:12px; bottom:85px; z-index:115; display:none; flex-direction:column; gap:8px; align-items:flex-end; pointer-events:auto;}
.car-small{width:70px; height:70px}

/* Pause overlay */
#pauseOverlay{position:absolute; inset:0; background:rgba(0,0,0,0.55); display:none; z-index:200; align-items:center; justify-content:center; color:#fff; font-size:20px;}
#pauseOverlay .box{background:rgba(0,0,0,0.6); padding:18px; border-radius:12px; border:1px solid rgba(255,255,255,0.06); text-align:center;}

@media(min-width:900px){
  #joystickArea{left:24px; bottom:24px; width:180px; height:180px;}
  #stick{width:80px; height:80px; left:50px; top:50px;}
  .car-btn{width:80px; height:80px; font-size:30px;}
  #shootBtn{width:88px; height:88px; right:22px; bottom:140px; font-size:26px;}
}
</style>

</head>
<body>
<div id="gameWrap">
  <canvas id="game"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div class="hud-row"><strong>Mode:</strong> <span id="modeText">On Foot</span></div>
    <div class="hud-row">Health<div class="bar"><div id="healthFill" class="bar-fill"></div></div></div>
    <div class="hud-row">Armor<div class="bar"><div id="armorFill" class="bar-fill"></div></div></div>
    <div class="hud-row hud-mini">Wanted: <span id="wantedVal">0</span> <span id="wantedStars"></span></div>
  </div>

  <!-- Minimap -->
  <canvas id="minimap"></canvas>
  
  <div id="mapPopup" style="
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
">
  <canvas id="bigMap" width="300" height="300" style="background:#222; border:3px solid white;"></canvas>
</div>

  <!-- Joystick -->
  <div id="joystickArea" aria-hidden="true">
    <div class="joystick-bg"></div>
    <div id="stick"></div>
  </div>

  <!-- Buttons -->
  <button id="shootBtn">üî´</button>
  <button id="enterBtn">üöò</button>
  <button id="pauseBtn">‚è∏Ô∏è</button>
  <button id="sprintBtn">üèÉ</button>

  <!-- Car controls left (TURN left/right) -->
  <div id="carControlsLeft" style="display:flex;">
    <button class="car-btn" id="carLeft">‚óÄ</button>
    <button class="car-btn" id="carRight">‚ñ∂</button>
  </div>

  <!-- Car controls right (UP/DOWN/EXIT) -->
  <div id="carControlsRight" style="display:flex;">
    <div style="display:flex; flex-direction:column; align-items:flex-end;">
      <button class="car-btn car-small" id="carUp">‚ñ≤</button>
      <button class="car-btn car-small" id="carDown">‚ñº</button>
      <button class="car-btn car-small" id="exitCar">üö™</button>
    </div>
  </div>

  <!-- Pause overlay -->
  <div id="pauseOverlay"><div class="box"><div style="font-weight:700;margin-bottom:8px">PAUSED</div><div>Tap resume to continue</div><div style="height:12px"></div><button id="resumeBtn" style="padding:8px 12px;border-radius:8px;border:none;background:#fff;color:#000">RESUME</button></div></div>
</div>

<script>
/* ============================
   Hybrid (C) - Full Game Script
   ============================ */

/* --- canvas / scaling --- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');

function resize(){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  mini.width = 120 * dpr;
  mini.height = 120 * dpr;
  mini.style.width = '120px';
  mini.style.height = '120px';
  mctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

/* --- Map loader: load map.json (with fallback generator) --- */

const TILE = 48;                // keep TILE same as before
let MAP_W = 120, MAP_H = 120;   // use let so we can resize to JSON map
let world = [];                 // world will be filled by JSON or fallback
let indoors = [];               // optional indoor map from JSON (kept for compatibility)

/* --- fallback generator (copied from your previous generator) --- */
function generateMapFallback(){
  // initialize
  for (let y = 0; y < MAP_H; y++) {
    world[y] = [];
    for (let x = 0; x < MAP_W; x++) {
      world[y][x] = 'building';
    }
  }

  // border water
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      if (x < 3 || y < 3 || x >= MAP_W - 3 || y >= MAP_H - 3) {
        world[y][x] = 'water';
      }
    }
  }

  // main roads (5 tiles wide)
  const mainEvery = 20;
  for (let i = 5; i < MAP_W - 5; i++) {
    if (i % mainEvery === 0) {
      for (let y = 0; y < MAP_H; y++) {
        for (let w = -2; w <= 2; w++) {
          if (world[y][i + w] !== 'water') world[y][i + w] = 'road';
        }
      }
    }
  }
  for (let j = 5; j < MAP_H - 5; j++) {
    if (j % mainEvery === 0) {
      for (let x = 0; x < MAP_W; x++) {
        for (let w = -2; w <= 2; w++) {
          if (world[j + w] && world[j + w][x] !== 'water') world[j + w][x] = 'road';
        }
      }
    }
  }

  // secondary roads (2 tiles)
  const secEvery = 10;
  for (let i = 0; i < MAP_W; i++) {
    if (i % secEvery === 0) {
      for (let y = 0; y < MAP_H; y++) {
        if (world[y][i] !== 'water') world[y][i] = 'road';
        if (world[y][i + 1] !== 'water') world[y][i + 1] = 'road';
      }
    }
  }
  for (let j = 0; j < MAP_H; j++) {
    if (j % secEvery === 0) {
      for (let x = 0; x < MAP_W; x++) {
        if (world[j][x] !== 'water') world[j][x] = 'road';
        if (world[j + 1] && world[j + 1][x] !== 'water') world[j + 1][x] = 'road';
      }
    }
  }

  // parks
  for (let y = 4; y < MAP_H - 4; y++) {
    for (let x = 4; x < MAP_W - 4; x++) {
      if (world[y][x] === 'building' && Math.random() < 0.02) world[y][x] = 'park';
    }
  }

  // simple shapes generation (keeps same behavior)
  function isValidBuilding(x, y) {
    if (x < 3 || y < 3 || x >= MAP_W - 3 || y >= MAP_H - 3) return false;
    if (world[y][x] === 'road' || world[y][x] === 'water' || world[y][x] === 'park') return false;
    return true;
  }
  function createRectBuilding(x, y) {
    let w = 3 + Math.floor(Math.random() * 4);
    let h = 3 + Math.floor(Math.random() * 4);
    for (let yy = y; yy < y + h; yy++) for (let xx = x; xx < x + w; xx++) if (isValidBuilding(xx, yy)) world[yy][xx] = 'building';
  }
  function createLongBuilding(x, y) {
    if (Math.random() < 0.5) {
      for (let xx = x; xx < x + 8; xx++) if (isValidBuilding(xx, y)) world[y][xx] = 'building';
    } else {
      for (let yy = y; yy < y + 8; yy++) if (isValidBuilding(x, yy)) world[yy][x] = 'building';
    }
  }
  function createLShapeBuilding(x, y) {
    for (let xx = x; xx < x + 4; xx++) if (isValidBuilding(xx, y)) world[y][xx] = 'building';
    for (let yy = y; yy < y + 4; yy++) if (isValidBuilding(x, yy)) world[yy][x] = 'building';
  }

  for (let y = 3; y < MAP_H - 3; y++) {
    for (let x = 3; x < MAP_W - 3; x++) {
      if (world[y][x] !== 'building') continue;
      let shape = Math.random();
      if (shape < 0.25) createRectBuilding(x, y);
      else if (shape < 0.45) createLongBuilding(x, y);
      else if (shape < 0.60) createLShapeBuilding(x, y);
    }
  }
}

/* --- initialize world from JSON data (data may be {world:[], indoors:[]}) --- */
function initWorldFromData(data){
  const arr = data.world || data; // accept either {world:[...]} or direct array
  if (!Array.isArray(arr) || !arr.length) throw new Error('invalid map data');
  MAP_H = arr.length;
  MAP_W = arr[0].length;
  world = new Array(MAP_H);
  indoors = new Array(MAP_H);
  for (let y=0;y<MAP_H;y++){
    world[y] = new Array(MAP_W);
    indoors[y] = new Array(MAP_W);
    for (let x=0;x<MAP_W;x++){
      world[y][x] = arr[y][x];
      indoors[y][x] = (data.indoors && data.indoors[y] && data.indoors[y][x]) ? true : false;
    }
  }
}

/* --- attempt to load map.json, else fallback to generator --- */
function loadMapJson(path='map.json'){
  return fetch(path)
    .then(resp => {
      if (!resp.ok) throw new Error('HTTP '+resp.status);
      return resp.json();
    })
    .then(data => {
      initWorldFromData(data);
      console.log('map.json loaded ‚Äî size:', MAP_W + 'x' + MAP_H);
    })
    .catch(err => {
      console.warn('map.json load failed, using fallback generator:', err);
      // keep default MAP_W/MAP_H and generate fallback
      generateMapFallback();
    });
}

/* start loading immediately; after load we will create civilians and start loop */
loadMapJson().then(()=>{
  // create civilians only after world is ready; createCivilians function exists below in your script,
  // so we wait until the symbol is available ‚Äî to be safe we check and defer slightly if needed.
  const waitForCreate = () => {
    if (typeof createCivilians === 'function') {
      // same default count you had before
      createCivilians(30);
      // start the main loop only once (we remove the final direct start elsewhere)
      last = performance.now();
      requestAnimationFrame(update);
    } else {
      // try again in short while (this should be quick)
      setTimeout(waitForCreate, 20);
    }
  };
  waitForCreate();
});

// Find a safe spawn tile
function findSpawnTile(map) {
    for (let y = 0; y < map.grid.length; y++) {
        for (let x = 0; x < map.grid[y].length; x++) {
            if (map.grid[y][x] === false) {
                return { x, y };
            }
        }
    }
    return { x: 0, y: 0 }; // fallback
}

// when map loads:
worldData = data;

const spawn = findSpawnTile(worldData);

// tile size = 32 (yours probably)
const TILE = 32;

// set player spawn in the middle of the tile
player.x = spawn.x * TILE + TILE / 2;
player.y = spawn.y * TILE + TILE / 2;

// same for car
car.x = spawn.x * TILE + TILE / 2;
car.y = spawn.y * TILE + TILE / 2;

/* --- Entities: player, car, bullets, npcs, cops --- */
const player = {
  x: (MAP_W/2 + 0.5)*TILE,
  y: (MAP_H/2 + 1.2)*TILE,
  r: 12,
  speed: 110,
  runMult: 1.8,
  inCar: false,
  hp: 100,
  armor: 100,
  ammo: 30
};

player.maxAmmo = 30;     // ammo capacity on foot
player.ammo = 30;        // starting ammo
player.reloading = false;
player.reloadTime = 5;    // seconds
player.reloadTimer = 0;

const car = {
  x: player.x + 60, y: player.y + 6,
  w: 36, h: 18,
  angle: 0, speed: 0, maxSpeed: 170, accel: 100, friction: 260, turnSpeed: 3.6, hp: 300, exists:true, occupied:false
};

let bullets = [];
let npcs = [];
let cops = [];

/* --- Civilians spawn (sidewalk-ish) --- */
function tileAt(px,py){
  const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);
  if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return 'water';
  return world[ty][tx];
}

function spawnOnRoad(){
  for (let i=0;i<300;i++){
    const tx = Math.floor(Math.random()*MAP_W);
    const ty = Math.floor(Math.random()*MAP_H);
    if (world[ty] && (world[ty][tx] === 'road' || world[ty][tx] === 'park')){
      const nx = tx*TILE + TILE*0.5 + (Math.random()-0.5)*TILE*0.6;
      const ny = ty*TILE + TILE*0.5 + (Math.random()-0.5)*TILE*0.6;
      return {x:nx,y:ny};
    }
  }
  return {x:player.x+80, y:player.y+80};
}

function createCivilians(n=1000){
  npcs = [];
  for (let i=0;i<n;i++){
    const s = spawnOnRoad();
    if (Math.random() < 0.5){
      // path follower loop
const baseX = Math.round(s.x / TILE) * TILE;
const baseY = Math.round(s.y / TILE) * TILE;
const loop = [
  { x: baseX + TILE*1.5, y: baseY - TILE*1.5 },
  { x: baseX + TILE*1.5, y: baseY + TILE*1.5 },
  { x: baseX - TILE*1.5, y: baseY + TILE*1.5 },
  { x: baseX - TILE*1.5, y: baseY - TILE*1.5 }
];

npcs.push({
  x: s.x,
  y: s.y,
  type: 'path',
  loop: loop,
  idx: 0,
  spd: 28 + Math.random() * 18,
  r: 9,
  hp: 40,
  alive: true
});

} else {

npcs.push({
  x: s.x,
  y: s.y,
  type: 'wander',
  dir: Math.random() * Math.PI * 2,
  spd: 28 + Math.random() * 22,
  r: 9,
  hp: 40,
  alive: true
});

}
  }
}    

/* --- UI refs & input --- */
const stick = document.getElementById('stick');
const joystickArea = document.getElementById('joystickArea');
const shootBtn = document.getElementById('shootBtn');
const enterBtn = document.getElementById('enterBtn');
const carControlsLeft = document.getElementById('carControlsLeft');
const carControlsRight = document.getElementById('carControlsRight');
const carLeft = document.getElementById('carLeft'), carRight = document.getElementById('carRight');
const carUp = document.getElementById('carUp'), carDown = document.getElementById('carDown'), exitCarBtn = document.getElementById('exitCar');
const modeText = document.getElementById('modeText');
const healthFill = document.getElementById('healthFill'), armorFill = document.getElementById('armorFill');
const wantedVal = document.getElementById('wantedVal'), wantedStars = document.getElementById('wantedStars');
const pauseBtn = document.getElementById('pauseBtn'), pauseOverlay = document.getElementById('pauseOverlay'), resumeBtn = document.getElementById('resumeBtn');

let input = { moveX:0, moveY:0 };
let joy = { x:0, y:0, activeId:null };
const STICK_RADIUS = 56;

/* --- Joystick handlers (safe preventDefault) --- */
function getRect(el){ return el.getBoundingClientRect(); }
function startStick(e){
  const p = (e.touches ? e.touches[0] : e);
  joy.activeId = p.identifier ?? 'mouse';
  handleStickMove(p);
  if (e.cancelable) e.preventDefault();
}
function moveStick(e){
  if (e.cancelable) e.preventDefault();
  const p = (e.touches ? [...e.touches].find(t=>t.identifier===joy.activeId) : e);
  if (!p) return;
  handleStickMove(p);
}
function endStick(e){
  joy.activeId = null;
  joy.x = joy.y = 0;
  stick.style.transform = `translate(0px,0px)`;
  input.moveX = input.moveY = 0;
  if (e && e.cancelable) e.preventDefault();
}
function handleStickMove(p){
  const area = getRect(joystickArea);
  const centerX = area.left + area.width/2;
  const centerY = area.top + area.height/2;
  let dx = p.clientX - centerX, dy = p.clientY - centerY;
  const dist = Math.hypot(dx,dy);
  if (dist > STICK_RADIUS){ dx = dx / dist * STICK_RADIUS; dy = dy / dist * STICK_RADIUS; }
  stick.style.transform = `translate(${dx}px, ${dy}px)`;
  joy.x = dx / STICK_RADIUS; joy.y = dy / STICK_RADIUS;
  input.moveX = joy.x; input.moveY = joy.y;
}

joystickArea.addEventListener('touchstart', (e)=>startStick(e), {passive:false});
joystickArea.addEventListener('touchmove', (e)=>moveStick(e), {passive:false});
joystickArea.addEventListener('touchend', (e)=>endStick(e), {passive:false});
joystickArea.addEventListener('mousedown', (e)=>{ startStick(e); window.addEventListener('mousemove', moveStick); });
window.addEventListener('mouseup', (e)=>{ endStick(e); window.removeEventListener('mousemove', moveStick); });

let sprinting = false;
const SPRINT_MULT = 2.0; // how much faster player moves when sprinting

const sprintBtn = document.getElementById('sprintBtn');

// Touch / mouse events
sprintBtn.addEventListener('touchstart', e => { if (e.cancelable) e.preventDefault(); sprinting = true; }, {passive:false});
sprintBtn.addEventListener('touchend', e => { if (e.cancelable) e.preventDefault(); sprinting = false; }, {passive:false});
sprintBtn.addEventListener('mousedown', () => sprinting = true);
window.addEventListener('mouseup', () => sprinting = false);

// Optional keyboard fallback
window.addEventListener('keydown', e => { if (e.key === 'Shift') sprinting = true; });
window.addEventListener('keyup', e => { if (e.key === 'Shift') sprinting = false; });

/* --- Buttons (shoot/enter) --- */
let shootPressed = false;
shootBtn.addEventListener('touchstart', (e)=>{ if (e.cancelable) e.preventDefault(); shootPressed = true; }, {passive:false});
shootBtn.addEventListener('touchend', (e)=>{ if (e.cancelable) e.preventDefault(); shootPressed = false; }, {passive:false});
shootBtn.addEventListener('mousedown', ()=> shootPressed = true);
window.addEventListener('mouseup', ()=> shootPressed = false);

enterBtn.addEventListener('click', ()=>{
  if (!player.inCar){
    const d = Math.hypot(player.x - car.x, player.y - car.y);
    if (d < 56 && car.exists !== false){
      player.inCar = true; car.occupied = true; modeText.textContent='In Car'; showVehicleUI(true);
    }
  } else {
    player.inCar = false;
    car.occupied = false;
    modeText.textContent = 'On Foot';
    showVehicleUI(false);

    const exitDist = car.w * 0.6;

    // right side position
    const rx = car.x + Math.cos(car.angle + Math.PI/2) * exitDist;
    const ry = car.y + Math.sin(car.angle + Math.PI/2) * exitDist;

    // left side position
    const lx = car.x + Math.cos(car.angle - Math.PI/2) * exitDist;
    const ly = car.y + Math.sin(car.angle - Math.PI/2) * exitDist;

    // check which side is safe to stand on
    const rightTile = tileAt(rx, ry);
    const leftTile  = tileAt(lx, ly);

    // preferred: right side, but only if safe
    if (rightTile !== "building" && rightTile !== "water") {
        player.x = rx;
        player.y = ry;
    } 
    // fallback: left side
    else {
        player.x = lx;
        player.y = ly;
    }
}
});

/* --- Car control binding --- */
let carInput = { left:false, right:false, up:false, down:false };
function bindBtn(btn, prop){
  btn.addEventListener('touchstart', (e)=>{ if (e.cancelable) e.preventDefault(); carInput[prop]=true; }, {passive:false});
  btn.addEventListener('touchend', (e)=>{ if (e.cancelable) e.preventDefault(); carInput[prop]=false; }, {passive:false});
  btn.addEventListener('mousedown', ()=> carInput[prop]=true);
  btn.addEventListener('mouseup', ()=> carInput[prop]=false);
}
bindBtn(carLeft,'left'); bindBtn(carRight,'right'); bindBtn(carUp,'up'); bindBtn(carDown,'down');
exitCarBtn.addEventListener('click', ()=>{
  if (player.inCar){ player.inCar=false; car.occupied=false; modeText.textContent='On Foot'; showVehicleUI(false); player.x = car.x + Math.cos(car.angle + Math.PI/2) * (car.w + 12); player.y = car.y + Math.sin(car.angle + Math.PI/2) * (car.w + 12); }
});

function showVehicleUI(inCar){
  if (inCar){
    joystickArea.style.display = 'none';
    carControlsLeft.style.display = 'flex';
    carControlsRight.style.display = 'flex';
  } else {
    joystickArea.style.display = 'block';
    carControlsLeft.style.display = 'none';
    carControlsRight.style.display = 'none';
  }
}

/* --- keyboard fallback --- */
const keys = {};
window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; if (e.key === ' ') enterBtn.click(); if (e.key === 'p') togglePause();});
window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

/* --- Civilians movement helpers --- */
function avoidBuildingWalk(entity, dt){
  const nx = entity.x + Math.cos(entity.dir) * entity.spd * dt;
  const ny = entity.y + Math.sin(entity.dir) * entity.spd * dt;
  if (tileAt(nx,ny) === 'building' || tileAt(nx,ny) === 'water'){
    entity.dir += (Math.random() > 0.5 ? 1 : -1) * (0.9 + Math.random()*1.6);
  } else {
    entity.x = nx; entity.y = ny;
  }
}

function avoidBuildingWalkCop(cop, targetX, targetY, dt) {
    // get current tile
    const currTile = worldTileFromPos(cop.x, cop.y);
    
    // find nearest road if not on road
    if (!isRoadTile(currTile.tx, currTile.ty)) {
        const nearest = findNearestRoad(cop.x, cop.y);
        if (nearest) {
            const dx = nearest.x - cop.x;
            const dy = nearest.y - cop.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 1) {
                cop.x += (dx/dist) * cop.speed * dt;
                cop.y += (dy/dist) * cop.speed * dt;
            }
        }
        return;
    }

    // on road: choose next road tile toward player/car
    const nextStep = chooseNextRoadStepFrom(currTile.tx, currTile.ty, targetX, targetY);
    if (!nextStep) return;

    const dx = nextStep.x - cop.x;
    const dy = nextStep.y - cop.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 1) {
        cop.x += (dx/dist) * cop.speed * dt;
        cop.y += (dy/dist) * cop.speed * dt;
    }
}

// ---- Road-aware helpers ----
function isRoadTile(tx, ty){
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return false;
  return world[ty][tx] === 'road';
}
function worldTileFromPos(px, py){
  return { tx: Math.floor(px / TILE), ty: Math.floor(py / TILE) };
}

// BFS to find nearest road tile within radius (returns {x,y} in world coords or null)
function findNearestRoad(px, py, radiusTiles = 10){
  const start = worldTileFromPos(px, py);
  const seen = new Set();
  const q = [{tx:start.tx, ty:start.ty, d:0}];
  seen.add(start.tx + ',' + start.ty);
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  while(q.length){
    const cell = q.shift();
    if (isRoadTile(cell.tx, cell.ty)) {
      return { x: cell.tx * TILE + TILE/2, y: cell.ty * TILE + TILE/2, tx:cell.tx, ty:cell.ty };
    }
    if (cell.d >= radiusTiles) continue;
    for (const di of dirs){
      const ntx = cell.tx + di[0], nty = cell.ty + di[1];
      const key = ntx + ',' + nty;
      if (ntx < 0 || nty < 0 || ntx >= MAP_W || nty >= MAP_H) continue;
      if (seen.has(key)) continue;
      seen.add(key);
      q.push({ tx: ntx, ty: nty, d: cell.d + 1 });
    }
  }
  return null;
}

// choose next road neighbor tile that decreases distance to player (greedy)
function chooseNextRoadStepFrom(tx, ty, targetX, targetY){
  const dirs = [
    {dx:1, dy:0}, {dx:-1, dy:0}, {dx:0, dy:1}, {dx:0, dy:-1}
  ];
  let best = null;
  let bestDist = Infinity;
  for (const d of dirs){
    const ntx = tx + d.dx, nty = ty + d.dy;
    if (!isRoadTile(ntx, nty)) continue;
    const cx = ntx*TILE + TILE/2, cy = nty*TILE + TILE/2;
    const dist = Math.hypot(targetX - cx, targetY - cy);
    if (dist < bestDist){
      bestDist = dist;
      best = { tx: ntx, ty: nty, x: cx, y: cy };
    }
  }
  return best;
}

/* --- Cops spawn --- */
function spawnCop() {
    // try 50 times to find a valid spawn
    for (let i = 0; i < 50; i++) {
        // pick a random tile in the map
        const tx = Math.floor(Math.random() * MAP_W);
        const ty = Math.floor(Math.random() * MAP_H);

        // must be a road tile
        if (!isRoadTile(tx, ty)) continue;

        // world coords
        const x = tx * TILE + TILE/2;
        const y = ty * TILE + TILE/2;

        // optionally make sure not too close to player
        const dist = Math.hypot(player.x - x, player.y - y);
        if (dist < 120) continue; // don't spawn too close

        cops.push({ x, y, speed: 50 + Math.random() * 40, hp: 90, shootTimer: 0 });
        return;
    }

    // fallback: spawn on central road
    const mid = Math.floor(MAP_W/2);
    cops.push({ x: mid * TILE + TILE/2, y: mid * TILE + TILE/2, speed: 20 + Math.random() * 40, hp: 90, shootTimer: 0 });
}


/* --- spawn initial cops empty --- */
cops = [];

/* --- civilian refill utility --- */
function refillCivilians(){ createCivilians(30); }

/* --- game state variables --- */
let bulletsTimer = 0, shootCooldown = 0;
let last = performance.now();
let wanted = 0, spawnTimer = 0;
let paused = false;

/* --- shooting --- */
function playerShoot() {

    // Unlimited ammo in car
    if (player.inCar) {
        if (shootCooldown > 0) return;

        let ang = Math.atan2(input.moveY, input.moveX);
        if (Math.hypot(input.moveX, input.moveY) < 0.2) ang = car.angle;

        const sx = car.x + Math.cos(car.angle)*10;
        const sy = car.y + Math.sin(car.angle)*10;

        bullets.push({
            x: sx, y: sy,
            vx: Math.cos(ang)*620,
            vy: Math.sin(ang)*620,
            life: 1.6,
            owner: 'player',
            dmg: 18
        });

        shootCooldown = 0.18;
        return;
    }

    // --- ON FOOT SHOOTING ---

    // block if reloading
    if (player.reloading) return;

    // if no ammo -> start reload
    if (player.ammo <= 0) {
        player.reloading = true;
        player.reloadTimer = player.reloadTime;
        return;
    }

    // normal shooting
    if (shootCooldown > 0) return;

    let ang = Math.atan2(input.moveY, input.moveX);
    if (Math.hypot(input.moveX, input.moveY) < 0.2) ang = 0;

    bullets.push({
        x: player.x,
        y: player.y,
        vx: Math.cos(ang)*620,
        vy: Math.sin(ang)*620,
        life: 1.6,
        owner: 'player',
        dmg: 18
    });

    player.ammo--;
    shootCooldown = 0.18;
}

/* --- utility functions --- */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function approach(a,b,delta){ return a<b ? Math.min(b,a+delta) : Math.max(b,a-delta); }

/* --- pause handling --- */
function setPaused(v){
  paused = v;
  pauseOverlay.style.display = v ? 'flex' : 'none';
}
function togglePause(){ setPaused(!paused); }
pauseBtn.addEventListener('click', ()=> togglePause());
resumeBtn.addEventListener('click', ()=> setPaused(false));

/* --- main update loop --- */
function getSafeExitPosition() {
  const dirs = [
    car.angle + Math.PI/2,    // right
    car.angle - Math.PI/2,    // left
    car.angle,                // front
    car.angle + Math.PI       // back
  ];

  const exitDist = 34; // distance from car
  for (let d of dirs) {
    const ex = car.x + Math.cos(d) * exitDist;
    const ey = car.y + Math.sin(d) * exitDist;
    if (tileAt(ex, ey) !== 'building' && tileAt(ex, ey) !== 'water') {
      return { x: ex, y: ey };
    }
  }

  // fallback: just move outward until safe
  for (let i=40; i<120; i+=10) {
    const ex = car.x + Math.cos(car.angle) * i;
    const ey = car.y + Math.sin(car.angle) * i;
    if (tileAt(ex, ey) !== 'building' && tileAt(ex, ey) !== 'water') {
      return { x: ex, y: ey };
    }
  }

  // final fallback = return car center (won't happen usually)
  return { x: car.x, y: car.y };
}

function update(now){
  const dt = Math.min(0.05,(now - last)/1000);
  last = now;
  if (paused){ requestAnimationFrame(update); return; }

// --- handle reloading ---
if (player.reloading) {
    player.reloadTimer -= dt;            // count down
    if (player.reloadTimer <= 0) {       // finished reloading
        player.reloading = false;
        player.ammo = player.maxAmmo;    // refill ammo
    }
}
  // keyboard fallback movement override when on foot
  if (!player.inCar){
    let mvx = 0, mvy = 0;
    if (keys['w']||keys['arrowup']) mvy = -1;
    if (keys['s']||keys['arrowdown']) mvy = 1;
    if (keys['a']||keys['arrowleft']) mvx = -1;
    if (keys['d']||keys['arrowright']) mvx = 1;
    if (mvx!==0 || mvy!==0){ input.moveX = mvx; input.moveY = mvy; }
  }

  /* player on foot */
  if (!player.inCar){
    const mag = Math.hypot(input.moveX, input.moveY);
    if (mag > 0.15){
      const speed = player.speed * (sprinting ? SPRINT_MULT : 1) * (keys['shift'] ? player.runMult : 1);
      player.x += (input.moveX / mag) * speed * dt;
      player.y += (input.moveY / mag) * speed * dt;
      if (tileAt(player.x,player.y) === 'building' || tileAt(player.x,player.y) === 'water'){
        player.x -= (input.moveX / mag) * speed * dt;
        player.y -= (input.moveY / mag) * speed * dt;
      }
    }
  } else {
    /* driving (robust collision-safe) */
{
  // steering input
  const steer = (carInput.left ? -1 : 0) + (carInput.right ? 1 : 0) + (keys['a']? -1:0) + (keys['d']?1:0);

  // determine forward/reverse intent
  const forwardPressed = (carInput.up || keys['w']);
  const reversePressed = (carInput.down || keys['s']);

  // target speed: forward full, reverse limited
  const REVERSE_FACTOR = 0.42;
  const targetSpeed = forwardPressed ? car.maxSpeed : (reversePressed ? -car.maxSpeed * REVERSE_FACTOR : 0);

  // accelerate / decelerate toward target
  if (car.speed < targetSpeed) car.speed = Math.min(car.speed + car.accel * dt, targetSpeed);
  else car.speed = Math.max(car.speed - car.friction * dt, targetSpeed);

  // allow rotation even when standing still
const steerFactor = (Math.abs(car.speed) > 1) ? (car.speed > 0 ? 1 : 0.55) : 1;
car.angle += steer * car.turnSpeed * dt * (Math.abs(car.speed)/car.maxSpeed + 0.49) * steerFactor;

  // proposed movement (separate axis to avoid corner tunneling)
  const moveX = Math.cos(car.angle) * car.speed * dt;
  const moveY = Math.sin(car.angle) * car.speed * dt;

  let nx = car.x + moveX;
let ny = car.y;
if (tileAt(nx, ny) === 'building') {
    // Bounce back proportionally to speed
    car.x -= Math.sign(moveX) * Math.min(Math.abs(moveX) * 0.5, 12); // push out
    car.speed *= -0.3; // reverse a portion of speed
    if (Math.abs(moveX) > 10 * dt) car.hp = Math.max(0, car.hp - Math.floor(Math.abs(moveX)*0.2));
} else {
    car.x = nx;
}

  nx = car.x;
ny = car.y + moveY;
if (tileAt(nx, ny) === 'building') {
    car.y -= Math.sign(moveY) * Math.min(Math.abs(moveY) * 0.5, 12);
    car.speed *= -0.3;
    if (Math.abs(moveY) > 10 * dt) car.hp = Math.max(0, car.hp - Math.floor(Math.abs(moveY)*0.2));
} else {
    car.y = ny;
}

  // If after both moves we're inside a building (rare), push out along negative movement vector
  if (tileAt(car.x, car.y) === 'building') {
    car.x -= Math.cos(car.angle) * 8;
    car.y -= Math.sin(car.angle) * 8;
    car.speed = 0;
    car.hp = Math.max(0, car.hp - 10);
  }

  // water kills car as before
  if (tileAt(car.x, car.y) === 'water') {
    car.hp = 0;
  }

  // keep player anchored to car when occupied
  if (car.occupied){
    player.x = car.x - Math.cos(car.angle)*26;
    player.y = car.y - Math.sin(car.angle)*26;
  }

  // OPTIONAL DEBUG: uncomment to print collisions to console (helps diagnose)
  // if (Math.random() < 0.01) console.log('car',car.x.toFixed(1),car.y.toFixed(1),'speed',car.speed.toFixed(1),'tile', tileAt(car.x,car.y));
}
  }

  /* shooting */
  shootCooldown = Math.max(0, shootCooldown - dt);
  if (shootPressed) playerShoot();

  // bullets update
for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    const nextX = b.x + b.vx * dt;
    const nextY = b.y + b.vy * dt;
    
    // ---- ammo reload process (on foot only) ----
if (!player.inCar && player.reloading) {
    player.reloadTimer -= dt;
    if (player.reloadTimer <= 0) {
        player.reloading = false;
        player.ammo = player.maxAmmo;  // refill
    }
}

    // destroy bullet if hitting wall or water
    if (tileAt(nextX, nextY) === 'building' || tileAt(nextX, nextY) === 'water') {
        bullets.splice(i, 1);
        continue;
    }

    b.x = nextX;
    b.y = nextY;
    b.life -= dt;
    if (b.life <= 0) { bullets.splice(i, 1); continue; }

    if (b.owner === 'player') {
        let hitSomething = false;

        // check cops
for (let j = cops.length - 1; j >= 0; j--) {
    const c = cops[j];
    if (Math.hypot(b.x - c.x, b.y - c.y) < 16) {
        c.hp -= b.dmg;

        // REMOVE COP IF DEAD
        if (c.hp <= 0) {
            cops.splice(j, 1);
        }

        bullets.splice(i, 1);
        hitSomething = true;
        break;
    }
}

        // check civilians if no cop was hit
if (!hitSomething) {
    for (let j = npcs.length - 1; j >= 0; j--) {
        const n = npcs[j];
        if (Math.hypot(b.x - n.x, b.y - n.y) < n.r) {

            // Damage the civilian instead of instant delete
            if (n.hp === undefined) n.hp = 30;   // give default HP if missing
            n.hp -= b.dmg;

            // remove bullet
            bullets.splice(i, 1);
            hitSomething = true;
            break;
        }
    }
}

        
    } else {
        // cop bullets
        if (player.inCar) {
            if (Math.hypot(b.x - car.x, b.y - car.y) < 26) {
                car.hp -= b.dmg;
                bullets.splice(i, 1);
            }
        } else {
            if (Math.hypot(b.x - player.x, b.y - player.y) < 18) {
                const dmg = b.dmg;
                const armorAbsorb = Math.min(player.armor, dmg * 0.5);
                player.armor -= armorAbsorb;
                player.hp -= (dmg - armorAbsorb);
                bullets.splice(i, 1);
            }
        }
    }
}

/* ---- CAR vs CIVILIAN HIT DAMAGE + KNOCKBACK ---- */
if (player.inCar && car.speed > 60) {   // only if car is moving fast
    for (let i = npcs.length - 1; i >= 0; i--) {
        const n = npcs[i];
        const dist = Math.hypot(n.x - car.x, n.y - car.y);

        if (dist < n.r + car.w * 0.4) {

            // give civilian hp if missing
            if (n.hp === undefined) n.hp = 30;

            // damage based on speed
            const dmg = car.speed * 0.6;
            n.hp -= dmg;

            // knockback vector
            const angle = Math.atan2(n.y - car.y, n.x - car.x);
            const force = car.speed * 0.8;   // adjust how far they fly
            n.vx = Math.cos(angle) * force;
            n.vy = Math.sin(angle) * force;

            // remove if dead
            if (n.hp <= 0) {
                npcs.splice(i, 1);
            }

            // slow car slightly
            car.speed *= 0.65;
        }
    }
}
  
  // update npcs
for (let i = npcs.length - 1; i >= 0; i--) {
    const n = npcs[i];

    // --- civilian death check ---
    if (n.hp !== undefined && n.hp <= 0) {
        wanted = clamp(wanted + 2, 0, 10); // wanted increases only on death
        npcs.splice(i, 1);
        continue;
    }
    
    // apply knockback velocity if exists
if (n.vx !== undefined && n.vy !== undefined) {
    n.x += n.vx * dt;
    n.y += n.vy * dt;

    // apply friction to slow knockback over time
    n.vx *= 0.85;
    n.vy *= 0.85;

    // remove very tiny velocities
    if (Math.abs(n.vx) < 1) n.vx = 0;
    if (Math.abs(n.vy) < 1) n.vy = 0;
}

    if (n.type === 'wander') {
        if (Math.random() < 0.01) n.dir += (Math.random() - 0.5) * 1.6;
        avoidBuildingWalk(n, dt);
    } else {
        const target = n.loop[n.idx];
        const dx = target.x - n.x;
        const dy = target.y - n.y;
        const d = Math.hypot(dx, dy);

        if (d < 10) {
            n.idx = (n.idx + 1) % n.loop.length;
        } else {
            n.x += (dx / d) * n.spd * dt;
            n.y += (dy / d) * n.spd * dt;

            if (tileAt(n.x, n.y) === 'building' || tileAt(n.x, n.y) === 'water') {
                n.x -= (dx / d) * n.spd * dt;
                n.y -= (dy / d) * n.spd * dt;
                n.idx = (n.idx + 1) % n.loop.length;
            }
        }
    }
}

  // cops spawn & behavior
  spawnTimer += dt;
  if (wanted >= 1 && spawnTimer > 1.0 && cops.length < Math.ceil(wanted)){
    spawnCop(); spawnTimer = 0;
  }
  for (let i=cops.length-1;i>=0;i--){
    const c = cops[i];
    const targetX = player.inCar ? car.x : player.x;
    const targetY = player.inCar ? car.y : player.y;
    const dx = targetX - c.x, dy = targetY - c.y;
    const dist = Math.hypot(dx,dy);
    avoidBuildingWalkCop(c, targetX, targetY, dt);
    c.shootTimer -= dt;

if (dist > 10 && dist < 320 && c.shootTimer <= 0) {
    // only allow shooting if cop is on a road tile
    const ct = worldTileFromPos(c.x, c.y);
    if (isRoadTile(ct.tx, ct.ty)) {
        c.shootTimer = 1.4 + Math.random() * 0.8;
        const ang = Math.atan2(dy, dx);
        bullets.push({
            x: c.x,
            y: c.y,
            vx: Math.cos(ang) * 200,
            vy: Math.sin(ang) * 320,
            life: 2.8,
            owner: 'cop',
            dmg: 10
        });
    }
}
}

  // wanted decay
  wanted = clamp(wanted - dt*0.08, 0, 10);

  // car explosion logic
  if (car.hp <= 0 && car.exists !== false){
    if (Math.hypot(player.x - car.x, player.y - car.y) < 120) player.hp = Math.max(0, player.hp - 30);
    if (car.occupied){ player.inCar=false; car.occupied=false; modeText.textContent='On Foot'; showVehicleUI(false); }
    car.exists = false; car.speed = 0;
  }
  
  // respawn car if destroyed
if (!car.exists) {
  // find a safe spawn point near the player
  let pos;
  for (let i = 0; i < 100; i++) { // try 100 times max
    pos = spawnOnRoad();
    const dist = Math.hypot(pos.x - player.x, pos.y - player.y);
    const tile = tileAt(pos.x, pos.y);
    if (dist > 100 && tile !== 'building' && tile !== 'water') break;
  }

  // respawn the car
  car.x = pos.x;
  car.y = pos.y;
  car.angle = 0;
  car.speed = 0;
  car.hp = 300;
  car.exists = true;
  car.occupied = false;

  // optional: show mode text if player is in car
  if (player.inCar) {
    player.inCar = false;
    modeText.textContent = 'On Foot';
    showVehicleUI(false);
  }
}

  // HUD update
  healthFill.style.width = clamp(player.hp,0,100) + '%';
  armorFill.style.width = clamp(player.armor,0,100) + '%';
  wantedVal.textContent = Math.floor(wanted);
  let s=''; for (let i=0;i<Math.floor(wanted);i++) s+='‚òÖ'; wantedStars.textContent = s;

  // simple death handling
  if (player.hp <= 0){
    player.hp = 100;
    player.armor = 100;
    player.x = (MAP_W/2)*TILE;
    player.y = (MAP_H/2)*TILE;
    wanted = 0;
    refillCivilians();

    // Reset cops so old AI doesn't keep shooting
    cops = [];
    spawnTimer = 0;
}

  draw();
  requestAnimationFrame(update);
}

/* --- draw function --- */
function draw(){
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  const camX = player.inCar ? car.x : player.x;
  const camY = player.inCar ? car.y : player.y;
  const vw = canvas.clientWidth, vh = canvas.clientHeight;

  // draw tiles
  const startCol = Math.floor((camX - vw/2)/TILE) - 2;
  const startRow = Math.floor((camY - vh/2)/TILE) - 2;
  const cols = Math.ceil(vw/TILE) + 6, rows = Math.ceil(vh/TILE) + 6;

  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      const tx = startCol + c, ty = startRow + r;
      if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) continue;
      const t = world[ty][tx];
      const px = tx*TILE - camX + vw/2, py = ty*TILE - camY + vh/2;
      if (t === 'water'){ ctx.fillStyle = '#1da3ff'; ctx.fillRect(px,py,TILE,TILE); }
      else if (t === 'park'){ ctx.fillStyle = '#58b25a'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.fillRect(px,py,TILE,TILE); }
      else if (t === 'building') {
    // find building bounds for this tile
    let bw = 1, bh = 1;

    // width
    while (tx + bw < MAP_W && world[ty][tx + bw] === 'building') bw++;

    // height
    while (ty + bh < MAP_H && world[ty + bh][tx] === 'building') {
        let fullRow = true;
        for (let i = 0; i < bw; i++) {
            if (world[ty + bh][tx + i] !== 'building') fullRow = false;
        }
        if (!fullRow) break;
        bh++;
    }

    // draw the building rect anchored to this tile
    const px2 = tx * TILE - camX + vw/2;
    const py2 = ty * TILE - camY + vh/2;

    ctx.fillStyle = '#2f2f2f';
    ctx.fillRect(px2, py2, bw*TILE, bh*TILE);

    ctx.fillStyle='rgba(255,255,255,0.05)';
    ctx.fillRect(px2 + 6, py2 + 6, bw*TILE - 12, bh*TILE - 12);
}
      else { ctx.fillStyle = '#bfbfbf'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.fillRect(px,py,TILE,TILE); }
    }
  }

  // npcs
  npcs.forEach(n=>{
    const sx = n.x - camX + vw/2, sy = n.y - camY + vh/2;
    ctx.beginPath(); ctx.fillStyle = '#ffd89b'; ctx.arc(sx,sy,n.r,0,Math.PI*2); ctx.fill();
  });
  
  npcs.forEach((n, idx) => {
    const dist = Math.hypot(n.x - car.x, n.y - car.y);
    if (dist < car.w / 2 + n.r && car.speed > 80) { // hit threshold
        // Remove civilian
        npcs.splice(idx, 1);

        // Knockback (optional, if using knockback)
        n.vx = (n.x - car.x) * 5;
        n.vy = (n.y - car.y) * 5;

        // Increase wanted level
        wanted = clamp(wanted + 1, 0, 10);
    }
});

  // cops
  cops.forEach(c=>{
    const sx = c.x - camX + vw/2, sy = c.y - camY + vh/2;
    ctx.beginPath(); ctx.fillStyle = '#4a6cff'; ctx.arc(sx,sy,12,0,Math.PI*2); ctx.fill();
  });

  // car
  if (car.exists !== false){
    const sx = car.x - camX + vw/2, sy = car.y - camY + vh/2;
    ctx.save(); ctx.translate(sx,sy); ctx.rotate(car.angle);
    ctx.fillStyle = '#ff6b6b'; ctx.fillRect(-car.w/2,-car.h/2,car.w,car.h);
    ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(4 - car.w/2, -car.h/2 + 2, car.w/2 - 6, car.h - 4);
    ctx.restore();
  }

  // player
if (!player.inCar) {
    const px = player.x - camX + vw/2;
    const py = player.y - camY + vh/2;
    ctx.beginPath();
    ctx.fillStyle = '#222';
    ctx.arc(px, py, player.r, 0, Math.PI*2);
    ctx.fill();
}

  // bullets
  bullets.forEach(b=>{
    const bx = b.x - camX + vw/2, by = b.y - camY + vh/2;
    ctx.beginPath(); ctx.fillStyle = b.owner === 'player' ? '#fff' : '#ffd1d1'; ctx.arc(bx,by,3,0,Math.PI*2); ctx.fill();
  });

  drawMinimap();
}

/* --- minimap --- */
function drawMinimap(){
  mctx.clearRect(0,0,mini.clientWidth,mini.clientHeight);

  const TILE_VIEW = 10; // number of tiles to show in minimap (width & height)
  const tileW = mini.clientWidth / TILE_VIEW;
  const tileH = mini.clientHeight / TILE_VIEW;

  // center player pixel
  const centerX = mini.clientWidth / 2;
  const centerY = mini.clientHeight / 2;

  // draw tiles around player
  const startPx = player.x - (TILE_VIEW/2) * TILE;
  const startPy = player.y - (TILE_VIEW/2) * TILE;

  for(let y=0; y<TILE_VIEW; y++){
    for(let x=0; x<TILE_VIEW; x++){
      const tx = Math.floor((startPx + x*TILE)/TILE);
      const ty = Math.floor((startPy + y*TILE)/TILE);
      if(tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) continue;

      const t = world[ty][tx];
      if(t==='water') mctx.fillStyle='#1da3ff';
      else if(t==='park') mctx.fillStyle='#3aa84f';
      else if(t==='building') mctx.fillStyle='#404040';
      else mctx.fillStyle='#bfbfbf';

      const px = x*tileW - (player.x % TILE) / TILE * tileW + tileW/2;
      const py = y*tileH - (player.y % TILE) / TILE * tileH + tileH/2;
      mctx.fillRect(px, py, tileW, tileH);
    }
  }

  // draw player in center
  mctx.fillStyle = '#00ff00';
  mctx.fillRect(centerX-2, centerY-2, 4,4);

  // draw car relative to player
  if(car.exists){
    const dx = (car.x - player.x)/TILE * tileW;
    const dy = (car.y - player.y)/TILE * tileH;
    mctx.fillStyle = '#ff9900';
    mctx.fillRect(centerX + dx -2, centerY + dy -2, 4,4);
  }

  // draw cops relative to player
  cops.forEach(c=>{
    const dx = (c.x - player.x)/TILE * tileW;
    const dy = (c.y - player.y)/TILE * tileH;
    mctx.fillStyle = '#3a3aff';
    mctx.fillRect(centerX + dx -2, centerY + dy -2, 4,4);
  });
}

/* --- FULL MAP POPUP --- */
const mapPopup = document.getElementById("mapPopup");
const bigMapCanvas = document.getElementById("bigMap");
const bctx = bigMapCanvas.getContext("2d");

mini.addEventListener("click", showBigMap);
mapPopup.addEventListener("click", ()=> mapPopup.style.display = "none");

function showBigMap() {
  mapPopup.style.display = "flex";
  drawFullMap();
}

function drawFullMap() {
  bctx.clearRect(0,0,bigMapCanvas.width,bigMapCanvas.height);

  const w = bigMapCanvas.width / MAP_W;
  const h = bigMapCanvas.height / MAP_H;

  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      const t = world[y][x];
      if(t==='water') bctx.fillStyle='#1da3ff';
      else if(t==='park') bctx.fillStyle='#3aa84f';
      else if(t==='building') bctx.fillStyle='#404040';
      else bctx.fillStyle='#bfbfbf';

      bctx.fillRect(x*w, y*h, w, h);
    }
  }

  // player marker
  bctx.fillStyle = "#00ff00";
  bctx.fillRect(player.x/TILE*w -2, player.y/TILE*h -2, 4, 4);

  // car
  if(car.exists){
    bctx.fillStyle = "#ff9900";
    bctx.fillRect(car.x/TILE*w -2, car.y/TILE*h -2, 4, 4);
  }

  // cops
  cops.forEach(c=>{
    bctx.fillStyle = "#3a3aff";
    bctx.fillRect(c.x/TILE*w -2, c.y/TILE*h -2, 4, 4);
  });
}

/* --- helper: double-tap refill civilians --- */
let lastTap = 0;
canvas.addEventListener('touchend',(e)=>{ const t = Date.now(); if (t - lastTap < 300) refillCivilians(); lastTap = t; });

/* --- enter car by touching near car --- */
canvas.addEventListener('touchstart', (e)=>{
  if (player.inCar) return;
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  // allow tapping near center to enter if close to car
  const d = Math.hypot(player.x - car.x, player.y - car.y);
  if (d < 56 && car.exists !== false){ player.inCar = true; car.occupied = true; modeText.textContent='In Car'; showVehicleUI(true); }
});


</script>
</body>
</html>
